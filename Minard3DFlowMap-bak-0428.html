<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Minard flow map</title>
    <style>
        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
        }
    </style>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no' />
    <script>L_DISABLE_3D = true;</script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.2/mapbox.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.2/mapbox.css' rel='stylesheet' />
    <link rel="stylesheet" type="text/css" href="css/timeCubeStyle.css">
</head>

<body>
<script src="lib/three.min.js"></script>
<script src="lib/tween.js"></script>
<script src="lib/MyTubeGeometry.js"></script>
<script src="lib/CSS3DRenderer.js"></script>
<script src="lib/TrackballControls.js"></script>
<script src="lib/three.js"></script>
<script src="lib/d3.min.js"></script>
<script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/build/three.min.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/renderers/CSS3DRenderer.js"></script>
<script src='https://api.mapbox.com/mapbox.js/v2.4.0/mapbox.js'></script>
<link href='https://api.mapbox.com/mapbox.js/v2.4.0/mapbox.css' rel='stylesheet' />

<script>

    var controls, camera, glScene, cssScene, glRenderer, cssRenderer;
    var map_length, map_width, map_height;
    map_length = 2800;
    map_width = 2400;
    map_height = 2000;
    var map_center = {lat: 54.875 , lng: 30.9};
    var map_scale = 8;

    function createGlRenderer() {
        var glRenderer = new THREE.WebGLRenderer({alpha:true});
        glRenderer.setClearColor(0xECF8FF);
        glRenderer.setPixelRatio(window.devicePixelRatio);
        glRenderer.setSize(window.innerWidth, window.innerHeight);
        glRenderer.domElement.style.position = 'absolute';
        glRenderer.domElement.style.zIndex = 1;
        glRenderer.domElement.style.top = 0;
        return glRenderer;
    }

    function createCssRenderer() {
        var cssRenderer = new THREE.CSS3DRenderer();
        cssRenderer.setSize(window.innerWidth, window.innerHeight);
        cssRenderer.domElement.style.position = 'absolute';
        glRenderer.domElement.style.zIndex = 0;
        cssRenderer.domElement.style.top = 0;
        return cssRenderer;
    }

    function createMap() {

        var material = new THREE.MeshBasicMaterial({
            color: 0x000000,
            opacity: 0.0,
            side: THREE.DoubleSide
        });
        var geometry = new THREE.PlaneGeometry(map_length, map_width);
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = 0;
        mesh.position.y = 0;
        mesh.position.z = 0;
        mesh.receiveShadow	= true;
        glScene.add(mesh);

        var mapstyles = ["mapbox.streets",
            "mapbox.light",
            "mapbox.dark",
            "mapbox.satellite",
            "mapbox.streets-satellite",
            "mapbox.wheatpaste",
            "mapbox.streets-basic",
            "mapbox.comic",
            "mapbox.outdoors",
            "mapbox.run-bike-hike",
            "mapbox.pencil",
            "mapbox.pirates",
            "mapbox.emerald",
            "mapbox.high-contrast"
        ];

        d3.selectAll('.map-div')
                .data([1]).enter()
                .append("div")
                .attr("class", "map-div")
                .attr("id","mappad")
                .each(function (d) {

                    var map = L.mapbox.map("mappad", "mapbox.emerald").setView([map_center.lat, map_center.lng],map_scale);

                    theMap = map;
                });

        var mapcontener = document.getElementById("mappad");
        var cssObject = new THREE.CSS3DObject(mapcontener);
        cssObject.position.x = 0;
        cssObject.position.y = 0;
        cssObject.position.z = 0;
        cssObject.receiveShadow	= true;
        //cssObject.rotation.x = 100;
        //cssObject.rotation.y = 100;
        //cssObject.rotation.z = 100;
        cssScene.add(cssObject);

    }

    function createColoredMaterial() {
        var material = new THREE.MeshBasicMaterial({
            color: Math.floor(Math.random() * 16777215),
            shading: THREE.FlatShading,
            side: THREE.DoubleSide
        });
        return material;
    }

    function creatTheAixs(){
        //create axis
        var material_axis = new THREE.LineBasicMaterial({color: 0x0000ff, opacity: 0.5});

        //create axis X
        var geometry_axisX = new THREE.Geometry();
        geometry_axisX.vertices.push(new THREE.Vector3( -map_length/2, -map_width/2, 0),new THREE.Vector3( map_length/2, -map_width/2, 0));
        var line_axisX = new THREE.Line( geometry_axisX, material_axis );
        //lineList["line_axisX"] = line_axisX;
        var geometry_axisX1 = new THREE.Geometry();
        geometry_axisX1.vertices.push(new THREE.Vector3( -map_length/2, map_width/2, 0),new THREE.Vector3( map_length/2, map_width/2, 0));
        var line_axisX1 = new THREE.Line( geometry_axisX1, material_axis );
        var geometry_axisX2 = new THREE.Geometry();
        geometry_axisX2.vertices.push(new THREE.Vector3( -map_length/2, -map_width/2, map_height),new THREE.Vector3( map_length/2, -map_width/2, map_height));
        var line_axisX2 = new THREE.Line( geometry_axisX2, material_axis );
        var geometry_axisX3 = new THREE.Geometry();
        geometry_axisX3.vertices.push(new THREE.Vector3( -map_length/2, map_width/2, map_height),new THREE.Vector3( map_length/2, map_width/2, map_height));
        var line_axisX3 = new THREE.Line( geometry_axisX3, material_axis );

        //create axis Y
        var geometry_axisY = new THREE.Geometry();
        geometry_axisY.vertices.push(new THREE.Vector3( -map_length/2, -map_width/2, 0),new THREE.Vector3( -map_length/2, map_width/2, 0));
        var line_axisY = new THREE.Line( geometry_axisY, material_axis );
        //lineList["line_axisY"] = line_axisY;
        var geometry_axisY1 = new THREE.Geometry();
        geometry_axisY1.vertices.push(new THREE.Vector3( map_length/2, -map_width/2, 0),new THREE.Vector3( map_length/2, map_width/2, 0));
        var line_axisY1 = new THREE.Line( geometry_axisY1, material_axis );
        var geometry_axisY2 = new THREE.Geometry();
        geometry_axisY2.vertices.push(new THREE.Vector3( -map_length/2, -map_width/2, map_height),new THREE.Vector3( -map_length/2, map_width/2, map_height));
        var line_axisY2 = new THREE.Line( geometry_axisY2, material_axis );
        var geometry_axisY3 = new THREE.Geometry();
        geometry_axisY3.vertices.push(new THREE.Vector3( map_length/2, -map_width/2, map_height),new THREE.Vector3( map_length/2, map_width/2, map_height));
        var line_axisY3 = new THREE.Line( geometry_axisY3, material_axis );

        //create axis Z
        var geometry_axisZ = new THREE.Geometry();
        geometry_axisZ.vertices.push(new THREE.Vector3( -map_length/2, -map_width/2, 0),new THREE.Vector3( -map_length/2, -map_width/2, map_height));
        var line_axisZ = new THREE.Line( geometry_axisZ, material_axis );

        var geometry_axisZ1 = new THREE.Geometry();
        geometry_axisZ1.vertices.push(new THREE.Vector3( map_length/2, -map_width/2, 0),new THREE.Vector3( map_length/2, -map_width/2, map_height));
        var line_axisZ1 = new THREE.Line( geometry_axisZ1, material_axis );
        var geometry_axisZ2 = new THREE.Geometry();
        geometry_axisZ2.vertices.push(new THREE.Vector3( -map_length/2, map_width/2, 0),new THREE.Vector3( -map_length/2, map_width/2, map_height));
        var line_axisZ2 = new THREE.Line( geometry_axisZ2, material_axis );
        var geometry_axisZ3 = new THREE.Geometry();
        geometry_axisZ3.vertices.push(new THREE.Vector3( map_length/2, map_width/2, 0),new THREE.Vector3( map_length/2, map_width/2, map_height));
        var line_axisZ3 = new THREE.Line( geometry_axisZ3, material_axis );

        //add all the element to sence
        glScene.add( line_axisX);
        glScene.add( line_axisX1);
        glScene.add( line_axisX2);
        glScene.add( line_axisX3);

        glScene.add( line_axisY);
        glScene.add( line_axisY1);
        glScene.add( line_axisY2);
        glScene.add( line_axisY3);

        glScene.add( line_axisZ);
        glScene.add( line_axisZ1);
        glScene.add( line_axisZ2);
        glScene.add( line_axisZ3);
    }

    function convert(vertex) {
        return new THREE.Vector3(vertex[0], vertex[1], vertex[2]);
    }

    function drawBoxLines(vertices,troops,temperatures) {
        var vertex, geometry, material, mesh;
        var max = d3.max(troops);
        var min = d3.min(troops);

        //set the range of troops
        var trooplinear = d3.scale.linear().domain([min, max]).range([2, 20]);
        var temperaturelinear = d3.scale.linear().domain([d3.min(temperatures), d3.max(temperatures)])
                .range([ "blue","red"]);

        var segments = new THREE.Object3D();
        vertices = vertices.map(convert);

        for (var i = 0, len = vertices.length - 1; i < len; i++) {
            var color = temperaturelinear(temperatures[i]);
            vertex = vertices[i];

            geometry = new THREE.CubeGeometry(trooplinear(troops[i]) , trooplinear(troops[i]) , 1);
            material = new THREE.MeshLambertMaterial({
                opacity: 1,
                transparent: true,
                color: color
            });

            mesh = new THREE.Mesh(geometry, material)
            mesh.position.x = vertex.x;
            mesh.position.y = vertex.y;
            mesh.position.z = vertex.z;
            //console.log("mesh.position",vertex);
            mesh.lookAt(vertices[1 + i]);
            mesh.castShadow = true;

            var length = vertex.distanceTo(vertices[1 + i]);
            mesh.scale.set(1, 1, length + trooplinear(troops[i])/2);
            mesh.translateZ(0.5 * length);
            segments.add(mesh);
        }
        return segments;
    }

    function drawCylinderLines(vertices,troops,temperatures,coor) {

        var vertex, geometry, material, mesh;
        //var max = d3.max(troops);
        //var min = d3.min(troops);
        //console.log("max",max,"min",min);

        var max = 96000;
        var min = 1;

        //set the range of troops
        var trooplinear = d3.scale.linear().domain([min, max]).range([2, 20]);
        var temperaturelinear = d3.scale.linear().domain([d3.min(temperatures), d3.max(temperatures)])
                .range([ "blue","red"]);

        var segments = new THREE.Object3D();
        vertices = vertices.map(convert);

        var polyline_options = { color: '#000' ,weight: 20};
        var line_points = [];
        for (var i = 1, len = vertices.length - 1; i < len; i++) {

            var path = new THREE.CatmullRomCurve3([vertices[i-1],vertices[i], vertices[i+1]]);
            var color = temperaturelinear(temperatures[i]);
            vertex = vertices[i];

            geometry = new THREE.TubeGeometry(path, 4 ,trooplinear(troops[i]) ,16);
            material = new THREE.MeshLambertMaterial({
                opacity: 1,
                transparent: true,
                color: color
            });

            mesh = new THREE.Mesh(geometry, material)
            mesh.castShadow = true;

            segments.add(mesh);

            /*
            var point1 = coor[i-1];
            var point2 = coor[i];
            line_points.push(point2);
            */
        }

        //var polyline = L.polyline(line_points, polyline_options).addTo(theMap);

        return segments;
    }

    function drawLinesOnPlane(troops,coor){

        var max = 96000;
        var min = 1;

        var trooplinear = d3.scale.linear().domain([min, max]).range([2, 20]);

        var polyline_options = { color: '#000' ,weight: 20};
        var line_points = [];
        for (var i = 1, len = coor.length - 1; i < len; i++) {

            var point1 = coor[i-1];
            var point2 = coor[i];
            line_points.push(point2);
        }

        var polyline = L.polyline(line_points, polyline_options).addTo(theMap);

        return polyline;
    }

    function createFlows() {
        //mapbox polyline options

        d3.json("data/minardData.json", function(error, data){
            //console.log("data",data);
            var pointOrigin = theMap.getPixelOrigin();

            var point_center = theMap.project(L.latLng(map_center.lat, map_center.lng));
            console.log("point_center",point_center,"pointOrigin",pointOrigin);

            var point = new THREE.Vector3(0,0,0);

            data.features.forEach(function(feature){

                var coor = [];

                var geometry = new THREE.Geometry();

                var points = [], troops = [], temperatures = [], count = feature.attribute.length;

                for(var i = 0; i < count; i++)
                {
                    var stop = feature.attribute[i];

                    var temp_point =  theMap.project( L.latLng(stop.Latitude, stop.Longitude));

                    point.x = temp_point.x - pointOrigin.x - map_length/2;
                    point.y = 2* point_center.y - temp_point.y - pointOrigin.y - map_width/2 ;
                    point.z = stop.Day*10;

                    geometry.vertices.push(
                            new THREE.Vector3(point.x - pointOrigin.x, 2* point_center.y - point.y - pointOrigin.y , i*10 )
                    );

                    coor.push({lat:stop.Latitude, lng:stop.Longitude });
                    points.push([point.x, point.y, point.z]);
                    troops.push(feature.attribute[i].Troops);
                    temperatures.push(feature.attribute[i].Temperature);

                }

                //console.log("coor", coor);

                var lineflyying = drawCylinderLines(points,troops,temperatures,coor);
                lineflyying.castShadow = true;
                lineflyying.receiveShadow = true;
                glScene.add(lineflyying);

                drawLinesOnPlane(troops,coor);

            });
        });

    }

    function initialize() {
        camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                10000);
        camera.position.set(0, -3000, 3500)
        glRenderer = createGlRenderer();
        cssRenderer = createCssRenderer();
        //document.body.appendChild(glRenderer.domElement);
        document.body.appendChild(cssRenderer.domElement);
        cssRenderer.domElement.appendChild(glRenderer.domElement);
        //glRenderer.shadowMapEnabled = true;
        glRenderer.shadowMap.enabled = true;
        glRenderer.shadowMap.type = THREE.PCFShadowMap;
        glRenderer.shadowMapAutoUpdate = true;
        cssRenderer.shadowMapEnabled = true;
        cssRenderer.shadowMapType = THREE.PCFShadowMap;
        cssRenderer.shadowMapAutoUpdate = true;


        glScene = new THREE.Scene();
        cssScene = new THREE.Scene();
        var ambientLight = new THREE.AmbientLight(0x555555);
        glScene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set( 1000, -2, 10 ).normalize();
        glScene.add(directionalLight);

        var directionalLight_3 = new THREE.DirectionalLight(0xFFFFFF, 1.0);
        directionalLight_3.position.set(1400, 800, 2300);
        directionalLight_3.target.position.set( 1400, 800, 0 );
        directionalLight_3.castShadow = true;
        directionalLight_3.shadow.camera.near	= 0.01;
        directionalLight_3.shadow.camera.far	= 3000;
        directionalLight_3.shadow.camera.top = 800;
        directionalLight_3.shadow.camera.bottom = -800;
        directionalLight_3.shadow.camera.left  = -1400;
        directionalLight_3.shadow.camera.right = 1400;

        //var helper = new THREE.CameraHelper( directionalLight_3.shadow.camera );
        glScene.add(directionalLight_3);
        //glScene.add(helper);

        L.mapbox.accessToken = 'pk.eyJ1IjoiaXRjYWVybyIsImEiOiJjaWxuZmtlOHQwMDA2dnNseWMybHhvMXh0In0.DObc4iUf1_86LxJGF0RHog';
        var theMap = null;

        creatTheAixs();

        createMap();

        createFlows();


        controls = new THREE.TrackballControls(camera,cssRenderer.domElement);
        controls.rotateSpeed = 2;
        controls.minDistance = 30;
        controls.maxDistance = 8000;

        update();
    }

    function update() {
        controls.update();
        glRenderer.render(glScene, camera);
        cssRenderer.render(cssScene, camera);
        requestAnimationFrame(update);
    }

    $(document ).ready(function() {
        initialize();
    });
</script>
</body>
</html>